input {
    file {
        mode => "read"
        path => "/usr/share/logstash/ingest_data/*"
        file_completed_action => "log" # this tells logstash to log to the file specified in file_completed_log_path once its done reading the input file.
        file_completed_log_path => "/usr/share/logstash/ingest_data/logstash_completed.log"
        type => "test"
    }
    tcp {
        host => "0.0.0.0"
        port => 5140
        type => syslog
    }
    udp {
        host => "0.0.0.0"
        port => 5140
        type => syslog
    }
    tcp {
        host => "0.0.0.0"
        port => 5141
        type => syslog5424
    }
    udp {
        host => "0.0.0.0"
        port => 5141
        type => syslog5424
    }
    beats {
        port => 5044
    }
}

filter {
    if [type] == "syslog" {
        grok {
            match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
            add_field => [ "received_at", "%{@timestamp}" ]
            add_field => [ "received_from", "%{host}" ]
            add_field => [ "program", "%{syslog_program}" ]
        }
        date {
            match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
        }
        grok {
            match => {
                "syslog_message" => "client: %{IPV4:client_id}"
            }
        }
        if [client_id] {
            mutate {
                add_field => { "client_id" => "%{client_id}" }
            }
        }
    }
    if [type] == "syslog5424" {
        grok {
            match => { "message" =>  "%{POSINT:syslog_version} %{TIMESTAMP_ISO8601:syslog_timestamp} (?:-|%{SYSLOGHOST:syslog_hostname})? (?:-|%{DATA:syslog_program}) (?:-|%{DATA:syslog_pid})? (?:-|%{DATA:syslog_msgid})? %{GREEDYDATA:syslog_message}"}
            add_field => [ "received_at", "%{@timestamp}" ]
            add_field => [ "received_from", "%{host}" ]
            add_field => [ "program", "%{syslog_program}" ]
        }
        date {
            match => [ "syslog_timestamp", "ISO8601" ]
        }
        mutate {
            replace => { "program" => "%{[@metadata][input][tcp][source][name]}" }
        }
    }
    if [type] == "test" {
        mutate {
            add_field => {
                "program" => "logstash"
            }
        }
    }
    if [fileset][module] == "system" {
        if [fileset][name] == "auth" {
        grok {
            match => { "message" => ["%{SYSLOGTIMESTAMP:[system][auth][timestamp]} %{SYSLOGHOST:[system][auth][hostname]} sshd(?:\[%{POSINT:[system][auth][pid]}\])?: %{DATA:[system][auth][ssh][event]} %{DATA:[system][auth][ssh][method]} for (invalid user )?%{DATA:[system][auth][user]} from %{IPORHOST:[system][auth][ssh][ip]} port %{NUMBER:[system][auth][ssh][port]} ssh2(: %{GREEDYDATA:[system][auth][ssh][signature]})?",
                    "%{SYSLOGTIMESTAMP:[system][auth][timestamp]} %{SYSLOGHOST:[system][auth][hostname]} sshd(?:\[%{POSINT:[system][auth][pid]}\])?: %{DATA:[system][auth][ssh][event]} user %{DATA:[system][auth][user]} from %{IPORHOST:[system][auth][ssh][ip]}",
                    "%{SYSLOGTIMESTAMP:[system][auth][timestamp]} %{SYSLOGHOST:[system][auth][hostname]} sshd(?:\[%{POSINT:[system][auth][pid]}\])?: Did not receive identification string from %{IPORHOST:[system][auth][ssh][dropped_ip]}",
                    "%{SYSLOGTIMESTAMP:[system][auth][timestamp]} %{SYSLOGHOST:[system][auth][hostname]} sudo(?:\[%{POSINT:[system][auth][pid]}\])?: \s*%{DATA:[system][auth][user]} :( %{DATA:[system][auth][sudo][error]} ;)? TTY=%{DATA:[system][auth][sudo][tty]} ; PWD=%{DATA:[system][auth][sudo][pwd]} ; USER=%{DATA:[system][auth][sudo][user]} ; COMMAND=%{GREEDYDATA:[system][auth][sudo][command]}",
                    "%{SYSLOGTIMESTAMP:[system][auth][timestamp]} %{SYSLOGHOST:[system][auth][hostname]} groupadd(?:\[%{POSINT:[system][auth][pid]}\])?: new group: name=%{DATA:system.auth.groupadd.name}, GID=%{NUMBER:system.auth.groupadd.gid}",
                    "%{SYSLOGTIMESTAMP:[system][auth][timestamp]} %{SYSLOGHOST:[system][auth][hostname]} useradd(?:\[%{POSINT:[system][auth][pid]}\])?: new user: name=%{DATA:[system][auth][user][add][name]}, UID=%{NUMBER:[system][auth][user][add][uid]}, GID=%{NUMBER:[system][auth][user][add][gid]}, home=%{DATA:[system][auth][user][add][home]}, shell=%{DATA:[system][auth][user][add][shell]}$",
                    "%{SYSLOGTIMESTAMP:[system][auth][timestamp]} %{SYSLOGHOST:[system][auth][hostname]} %{DATA:[system][auth][program]}(?:\[%{POSINT:[system][auth][pid]}\])?: %{GREEDYMULTILINE:[system][auth][message]}"] }
            pattern_definitions => {
            "GREEDYMULTILINE"=> "(.|\n)*"
            }
            remove_field => "message"
        }
        date {
            match => [ "[system][auth][timestamp]", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
        }
        geoip {
            source => "[system][auth][ssh][ip]"
            target => "[system][auth][ssh][geoip]"
        }
        }
        else if [fileset][name] == "syslog" {
        grok {
            match => { "message" => ["%{SYSLOGTIMESTAMP:[system][syslog][timestamp]} %{SYSLOGHOST:[system][syslog][hostname]} %{DATA:[system][syslog][program]}(?:\[%{POSINT:[system][syslog][pid]}\])?: %{GREEDYMULTILINE:[system][syslog][message]}"] }
            pattern_definitions => { "GREEDYMULTILINE" => "(.|\n)*" }
            remove_field => "message"
        }
        date {
            match => [ "[system][syslog][timestamp]", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
        }
        }
    }
    if [@metadata][beat] {
        mutate {
            add_tag => ["filebeat"]
        }
    }
}

output {
    if "filebeat" in [tags] {
        elasticsearch {
            index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"

            hosts=> "${ELASTIC_HOSTS}"
            user=> "${ELASTIC_USER}"
            password=> "${ELASTIC_PASSWORD}"

            ssl_enabled => true
            ssl_certificate_authorities => ["config/certs/ca/ca.crt"]
            ssl_certificate => "config/certs/aether/aether.crt"
            ssl_key => "config/certs/aether/aether.pkcs8.key"
            manage_template => false
        }
    }
    else {
        elasticsearch {
            index => "%{[program]}-%{+YYYY.MM.dd}"

            hosts=> "${ELASTIC_HOSTS}"
            user=> "${ELASTIC_USER}"
            password=> "${ELASTIC_PASSWORD}"

            ssl_enabled => true
            ssl_certificate_authorities => ["config/certs/ca/ca.crt"]
            ssl_certificate => "config/certs/aether/aether.crt"
            ssl_key => "config/certs/aether/aether.pkcs8.key"
        }
    }
}
